#version 450
layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout ( std430, set = 0, binding = 1 ) buffer OctreeStorageBuffer
{ 
	uvec2 data[]; 
} uOctree;

layout ( std430, set = 0, binding = 2 ) readonly buffer FragmentListStorageBuffer
{ 
	uvec2 data[]; 
} uFragmentList;

// layout ( set = 0, binding = 5, r32ui ) uniform uimageBuffer uOctreeBrickPool; 

layout ( push_constant ) uniform constants
{
	uint fragmentNum;
	uint voxelResolution;
} uPushConstants;

// Below schemes are referred from OpenGL Insight Chapter 22
vec4 convRGBA8ToVec4( uint val);
uint convVec4ToRGBA8( vec4 val);
void atomicRGBA8Avg( uint index, vec4 val );
void imageAtomicRGBA8Avg( int index, vec4 val );

void main()
{
    if (gl_GlobalInvocationID.x >= uPushConstants.fragmentNum)
	{
		return;
	}
	
	uvec2 fragmentData = uFragmentList.data[gl_GlobalInvocationID.x];
	uvec3 fragPos = uvec3(
		fragmentData.x & 0xfffu, 
		(fragmentData.x >> 12u) & 0xfffu,
		((fragmentData.x >> 24u) & 0xffu) | ((fragmentData.y >> 20u) & 0xf00u)
	) >> 1;

	uint resolution = uPushConstants.voxelResolution;
	uint idx = 0, cur = 0; 
	uvec3 cmp;
	do {
		resolution >>= 1;
		cmp = uvec3(greaterThanEqual(fragPos, uvec3(resolution)));
		idx = cur + (cmp.z | (cmp.x << 1) | (cmp.y << 2));  // TODO(snowapril) : why rotation work?
		cur = uOctree.data[idx].x & 0x3fffffff; // Without MSB flag
		fragPos -= cmp * resolution;
	} while (cur != 0u && resolution > 1u);

	if (resolution == 1u) // Leaf node
	{
		// uvec3 fragsPos = uvec3(
		// fragmentData.x & 0xfffu, 
		// (fragmentData.x >> 12u) & 0xfffu,
		// ((fragmentData.x >> 24u) & 0xffu) | ((fragmentData.y >> 20u) & 0xf00u)) >> 1;
		// atomicRGBA8Avg(idx, vec4(0.3f, 0.5f, 0.7f, 1.0f));

		// int brickIndex = int(uOctree.data[idx].y);
		// {
		// 	// imageAtomicRGBA8Avg(brickIndex, convRGBA8ToVec4(fragmentData.y & 0xfffffffu));
		// }

		// uOctree.data[idx].y = fragmentData.y & 0xfffffffu;
		atomicRGBA8Avg(idx, convRGBA8ToVec4(fragmentData.y & 0xfffffffu));
	}
}

vec4 convRGBA8ToVec4( uint val) 
{	
	return vec4 (
		float (( val & 0x000000ff )), 
		float (( val & 0x0000ff00) >>  8u ),
		float (( val & 0x00ff0000) >> 16u ),
		float (( val & 0x3f000000) >> 24u )
	);
}

uint convVec4ToRGBA8( vec4 val)
{
	return ( 
		(uint(val.w) & 0x000000ff) << 24u | 
		(uint(val.z) & 0x000000ff) << 16u | 
		(uint(val.y) & 0x000000ff) <<  8u | 
		(uint(val.x) & 0x000000ff) | 0x30000000
	);
}

void atomicRGBA8Avg( uint index, vec4 val )
{
	val.rgb *= 255.0f; // Optimise following calculations
	uint newVal = convVec4ToRGBA8(val);
	uint prevStoredVal = 0; uint curStoredVal;

	// Loop as long as destination value gets changed by other threads
	while ( ( curStoredVal = atomicCompSwap( uOctree.data[index].y, prevStoredVal, newVal )) != prevStoredVal) 
	{
		prevStoredVal = curStoredVal;
		vec4 rval = convRGBA8ToVec4( curStoredVal);
		rval.xyz = (rval.xyz * rval.w); 	// Denormalize
		vec4 curValF = rval + val; 			// Add new value
		curValF.xyz /= (curValF.w); 		// Renormalize
		newVal = convVec4ToRGBA8(curValF);
	}
}

// void imageAtomicRGBA8Avg( int index, vec4 val )
// {
// 	uint newVal = convVec4ToRGBA8(val);
// 	uint prevStoredVal = 0; uint curStoredVal;
// 
// 	// Loop as long as destination value gets changed by other threads
// 	while ( ( curStoredVal = imageAtomicCompSwap( uOctreeBrickPool, index, prevStoredVal, newVal )) != prevStoredVal) 
// 	{
// 		prevStoredVal = curStoredVal;
// 		vec4 rval = convRGBA8ToVec4( curStoredVal);
// 		rval.xyz = (rval.xyz * rval.w); 	// Denormalize
// 		vec4 curValF = rval + val; 			// Add new value
// 		curValF.xyz /= (curValF.w); 		// Renormalize
// 		newVal = convVec4ToRGBA8(curValF);
// 	}
// }